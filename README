Project Overview
	The basic goal of the project was to create a poetry generator that, when you call it and tell it to “print”, should create two to three verses of poetry. Each verse should be four lines each, with varying lengths of about four to six words. In theory, each line should take a distinct, grammatical form, like starting with a pronoun, and then an adjective, and then a noun and then another adjective. In reality, I only got part way there - as of right now the code will print different “lines” of poetry, but each line takes the same four or five basic words from the master list, and then prints them in different orders. 
	The intention of the project was to be a “nonhuman poetry generator”, which is still a poetry generator, but meant to create poetry from a nonhuman animal perspective. I’m not equipped to rewrite the english language from a different perspective, but I wanted each line to follow the way nonhuman animals take in information from their physical environments - physical senses first, and then action, and then maybe judgment. This idea comes from seeing how certain animals - like Koko the Gorilla, who learned American Sign Language, or dogs trained by speech pathologists that press buttons to have an automated voice say specific words - will try to express themselves in human language. 

Project Narrative
	The main thing that helped me was the text generation example you provided, about making new tweets from Dril. This influenced a lot of the work for my first milestone, where I started to make a single, master-list for all the words that would be used in the poetry generator, called “Grammar”. All of the different words were divided into separate lists based on their parts of speech, like “adjective”, “noun”, “pronoun” and “verb”. The first function I created was “sentence_generator”, which would follow a specific format to create a sentence. The format of the sentence generator was a randomly chosen adjective, followed by a randomly chosen pronoun, followed by a randomly chosen verb, followed by a connecting word (“the”), and finished with a randomly chosen noun. I had to import “random” to be able to use the random.choice function so I could have variations in what words were being printed.
	For the second milestone, I figured that I would string different functions together that could make different sentences, and then create a function that would use the existing functions to print a rough verse of poetry. This gave me the “multi_sentence” function, which would take a list of different sentence types I’ve created - sentences that when asked to print, would print a set of words like the sentence_generator, but in random orders - and print out four randomly chosen sentences. I think that the idea for creating different functions in the beginning of my code, and then using them in larger functions that would print random variables - choosing the smaller functions at random - came from your lecture on making our own version of “blaseball”. Where the first milestone was successful in calling a different sentence, this milestone was a little less successful. As I said earlier, the problem with the “multi_sentence” function was that the generated sentences would latch onto the same set of four words, and then print them out in different orders. In one way, this worked in creating four different lines that, on their own, made a little bit of sense, but the “verses” generated made no sense when read from the first line to the last. 
	The surprising thing about this project was how - after you get the swing of things, “python” feels pretty intuitive to work with. I am nowhere close to being adept with the programming language, but it was interesting to see how easy working with the code felt once I got the syntax down. In the beginning, working with python felt like algebra - you have to set values to variables, and then “plug them in” in a specific order to have a function work. However, it seemed like, the more I worked with the code, the more successful it was when I turned my brain off, almost. It’s hard to explain, but it seems like there’s a point where you can form your thoughts in the right way, based on python, and then it seems natural almost. I still have a long, long way to go if I want to continue learning coding, but the experience was really interesting because of this - even if it’s hard to explain.
	If I approached this project again, I think the main thing I would focus on would be finding a way to incorporate different parts of grammar into the generator. This would be like making sure that certain words - nouns, and maybe (sometimes) the first letter of a line - were capitalized. I don’t think that a non-human animal would think within the confines of human grammar, but it would make the poems much easier to read. I would also want to incorporate different forms of punctuation, like dashes, commas and periods. I think to do that, I would just have to make a list of punctuation as different strings, and then have them be randomly chosen in the sentence generator, like I’ve done with the other words. Honestly, it might make things harder to understand - but it would give the project more style. The most important thing, though, would be to figure out how to have the sentence generators each pull four-five different words from “grammar”. 

Corrections
	For the first milestone, you said to correct the structure of the project so it was more efficient. To do this, I changed the file name for my python project from “project milestone” to “project_milestone.py”, so the repository would know that the code was written in python. Also, you said to find ways to increase complexity and randomness in the code. This led to me creating different sentence structures - “sentence”, “chaos_sentence”, “another_sentence”, “aanother_sentence” - and putting them all into a list called “all sentences” (line 50). The function I created for the second milestone - “multi_sentence” , on line 54 - printed four randomly chosen sentences from the big list of sentences. 
	For the second milestone, you said to find a way to create some kind of variation in the words printed, and maybe add some form of capitalization. I tried to approach this from two different angles. The first is, with “multi_sentence” (line 54). Instead of having four randomly chosen sentences being printed, I changed the last two sentences to be printed to be “chaos_sentence” and “sentence”. My reasoning for this was that, maybe if I had specific sentence templates printed from “grammar” (line 16), then these specific sentences would choose different words from the “grammar” list, instead of randomly choosing the same words from the “all_sentences” list. While this made sense in theory, the two specific sentences at the end of the function ended up choosing the same words as the random sentences at the beginning. Also, I didn’t want to change the two previous sentences being printed from “multi_sentence”, because I wanted to retain some kind of randomness/variation in the function. The second method was to create a second function, called “another_one” (line 61), that would print four randomly chosen sentences like “multi_sentence”. Then, I made a function called “a_little_poem” (line 68) that would print “multi_sentence”, and then “another_one”. The goal for this was to make two different “verses” of poetry that would print, and because it used different functions the idea was that each function would choose a different set of words. Unfortunately, “a_little_poem” chooses the same sets of words, but at least it prints them out in two verses in different orders - which is a tiny victory. 
	
	
